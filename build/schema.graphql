type NftContract @entity {
  id: ID!
  metadata: NftContractMetadata! @derivedFrom(field: "contract")

  # Stats
  timestamp: BigInt!
  updated_at: BigInt!
  total_supply: BigInt!

  # Relationships
  nfts: [Nft!]! @derivedFrom(field: "contract")
}

type NftContractMetadata @entity {

  "Metadata ID (Contract ID)"
  id: ID!

  "Contract ID of the particular metadata"
  contract: NftContract!

  # NEP-177
  "Current version of the contract"
  spec: String!

  "Name of the contract"
  name: String!

  "Short symbol phrase of the contract"
  symbol: String!

  "Data URL which contains icon of the contract"
  icon: String

  "Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs"
  base_uri: String

  "URL to a JSON file contains more info about the contract"
  reference: String

  "Base64-encoded string of packages script of the contract if there is any"
  packages_script: String

  "Base64-encoded string of the render script of the contract if there is any"
  render_script: String

  "Base64-encoded string of CSS styles of the contract if there is any"
  style_css: String

  "Base64-encoded string of Parameters of the contract if there is any"
  parameters: String


  # Extra
  "Mint price of the NFTs in contract"
  mint_price: BigInt!

  "Maximum number of copies for each NFT that contract generate"
  max_copies: Int

  "Maximum number of royalties that can payout for each NFT in the contract"
  default_max_len_payout: Int

  "Number of mints allowed for an account"
  mints_per_address: Int

  "Address that receives the full minting payment"
  mint_payee_id: User

  "Account that is set to receive perpetual royalty amount"
  mint_royalty_id: User

  "Amount of royalty, in percentage, that is set on each minted token"
  mint_royalty_amount: BigInt

  "Minimum amount of a bid that can be placed to a token in contract"
  min_bid_amount: BigInt!
}

type Nft @entity {
  id: ID!

  # Relationships
  contract: NftContract!
  metadata: NftMetadata! @derivedFrom(field: "nft")
  history: [Activity!]! @derivedFrom(field: "nft")

  # Ownership
  owner: User!
  creator: User!
  prev_owner: User

  # Market
  ## royalties
  royalties: [User!]
  royalties_percentage: Int

  ## ask
  askedPrice: Int

  ## shares
  owner_share: Int
  creator_share: Int
  prev_owner_share: Int

  ## bids
  bids: [Bid!] @derivedFrom(field: "nft")
}

type NftMetadata @entity {
  id: ID!
  nft: Nft!

  title: String!
  description: String
  media: String!
  media_animation: String
  media_hash: String
  copies: Int
  extra: String
  reference: String
  reference_hash: String
  issued_at: String
  starts_at: String
  updated_at: String
  expires_at: String
}

type User @entity {
  id: ID!

  # Relationships
  ownedNfts: [Nft!] @derivedFrom(field: "owner")
  createdNfts: [Nft!] @derivedFrom(field: "creator")
  bids: [Bid!] @derivedFrom(field: "bidder")

  # Stats
  total_owned: BigInt!
  total_minted: BigInt!
}

type Activity @entity {
  id: ID!
  nft: Nft!
  type: ActivityType!
  timestamp: BigInt!

  # mint activity
  mintBy: User

  # burn activity
  burnBy: User

  # transfer activity
  transferFrom: User
  transferTo: User

  transactionHash: String!
}

enum ActivityType @entity {
  mint
  burn
  transfer
}

type Bid @entity {
  id: ID!
  nft: Nft!
  timestamp: BigInt!

  amount: BigInt!
  bidder: User!
  recipient: User!
  sell_on_share: Int!
  currency: String!

  accepted: Boolean!
}
